{"backend_state":"init","connection_file":"/tmp/xdg-runtime-user/jupyter/kernel-b9cb86c4-2130-499c-8025-49d5cc1e1f82.json","kernel":"python3","kernel_error":"","kernel_state":"idle","kernel_usage":{"cpu":0,"memory":0},"metadata":{"language_info":{"codemirror_mode":{"name":"ipython","version":3},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython3","version":"3.8.5"}},"trust":true,"type":"settings"}
{"cell_type":"code","exec_count":0,"id":"f2fe1d","input":"","pos":79,"type":"cell"}
{"cell_type":"code","exec_count":1,"id":"47205e","input":"# pip install cf-python","pos":5,"type":"cell"}
{"cell_type":"code","exec_count":10,"id":"14405f","input":"# As before, we define a variable to store the time-mean output and give it a name that makes sense.\nglobal_warming_data = get_time_mean_data('feedback', 'TREFHT', 'ann', [75,94])\nbaseline_data = get_time_mean_data('control', 'TREFHT', 'ann', [10,29])\n# We can directly plot the anomaly by subtracting one from the other, and asking cfp.con to plot the result.\ncfp.con(global_warming_data - baseline_data)","output":{"0":{"data":{"image/png":"60d84fd9089973da3dfb1d703bfc98e036eab6e5","text/plain":"<Figure size 842.4x597.6 with 3 Axes>"},"exec_count":10,"metadata":{"image/png":{"height":534,"width":728},"needs_background":"light"},"output_type":"execute_result"}},"pos":22,"type":"cell"}
{"cell_type":"code","exec_count":10,"id":"194fa2","input":"# COPY YOUR CODE FROM ABOVE AND MODIFY IT.","pos":26,"type":"cell"}
{"cell_type":"code","exec_count":11,"id":"3e9b9e","input":"# YOUR MAX TEMP MAP PLOT CODE HERE.","pos":31,"type":"cell"}
{"cell_type":"code","exec_count":12,"id":"7e854e","input":"# COPY YOUR CODE FROM ABOVE AND MODIFY IT.","pos":34,"type":"cell"}
{"cell_type":"code","exec_count":13,"id":"f5a37a","input":"# let's set the variable to plot. defining a variable means we don't have to repeat ourselves and there's less chance of making mistakes.\nvar_2_plot = 'PRECT'\nseas_2_plot = 'ann'\n\n# Gather the annual-mean temperature data for the 3 cases\nglobal_warming_data = get_time_mean_data('control', var_2_plot, seas_2_plot, [75,94])\nbaseline_data = get_time_mean_data('control', var_2_plot, seas_2_plot, [10,29])\nsolar_geo_data = get_time_mean_data('feedback', var_2_plot, seas_2_plot, [75,94])\n\n# Now we define the anomaly (difference) between the future and baseline cases.\nglobal_warming_pc_anom = 100. * (global_warming_data / baseline_data - 1.0)\nsolar_geo_pc_anom = 100. * (solar_geo_data / baseline_data - 1.0)\n\n# Now, we set the contours and colorbar settings.\n# cfp.levs() defines the levels for the contourplot, leaving it blank let's the program choose the levels itself. Any values set here will be used in later plots but this can be reset by making a blank call with cfp.levs().\ncfp.levs()\n# cfp.cscale() defines the colorscale for the contourplot, leaving it blank let's the program choose the colour scale itself.\ncfp.cscale()\n\n# Now we plot the contour plots.\ncfp.con(global_warming_pc_anom, title='global warming - Precipitation Change (%)', colorbar_title='Precipitation Change (%)')\ncfp.con(solar_geo_pc_anom, title='solar geoengineering - Precipitation Change (%)', colorbar_title='Precipitation Change (%)')\n\ncfp.levs()\ncfp.cscale()\ncfp.con(baseline_data, title='Baseline Precipitation (mm/day)', colorbar_title='Precipitation (mm/day)')","output":{"0":{"data":{"image/png":"5d4478f44107c91eaebdcd8856d9e0a9aff7c392","text/plain":"<Figure size 842.4x597.6 with 3 Axes>"},"exec_count":13,"metadata":{"image/png":{"height":534,"width":728},"needs_background":"light"},"output_type":"execute_result"},"1":{"data":{"image/png":"9816ad917d7e75867be7690e8fc73ad5ece78efd","text/plain":"<Figure size 842.4x597.6 with 3 Axes>"},"exec_count":13,"metadata":{"image/png":{"height":534,"width":728},"needs_background":"light"},"output_type":"execute_result"},"2":{"data":{"image/png":"c014d05307ac7028f8d21b1065e072aa8a49812f","text/plain":"<Figure size 842.4x597.6 with 3 Axes>"},"exec_count":13,"metadata":{"image/png":{"height":534,"width":728},"needs_background":"light"},"output_type":"execute_result"}},"pos":36,"type":"cell"}
{"cell_type":"code","exec_count":14,"id":"16a0cb","input":"# YOUR CODE HERE.","pos":39,"type":"cell"}
{"cell_type":"code","exec_count":15,"id":"018b94","input":"# YOUR CODE HERE","pos":42,"type":"cell"}
{"cell_type":"code","exec_count":16,"id":"bd3cef","input":"# YOUR CODE HERE.","pos":45,"type":"cell"}
{"cell_type":"code","exec_count":17,"id":"df289f","input":"def get_regional_data_and_mean(experiment, variable, season, lon_range, lat_range, year_range):\n    # calculates the regional time mean.\n    # Same inputs as get_time_mean_data but also you must specify:\n    # lat_range = [lat_min, lat_max], e.g, [20, 35]\n    # lon_range = [lon_min, lon_max], e.g, [100, 135]\n    \n    if len(year_range) != 2 or len(lon_range) != 2 or len(lat_range) != 2:\n        print('year_range, lon_range, lat_range must have 2 elements, you inputted:', year_range, lon_range, lat_range)\n    \n    # Select the correct filename format and select the correct indices.\n    if experiment == 'control':\n        exp_filename = 'control.001.cam.h0.{VAR}.201001-209912.{SEAS}.nc'\n        index_range = [year_range[0] - 10, year_range[1] - 10] # starts in year 2010 so -10\n    elif experiment == 'feedback':\n        exp_filename = 'feedback.001.cam.h0.{VAR}.202001-209912.{SEAS}.nc'\n        index_range = [year_range[0] - 20, year_range[1] - 20] # starts in year 2020 so -20\n    else:\n        print(experiment, 'not recognized. must be either control or feedback')\n    \n    # Specify filename and location for the data\n    data_dir = Path(\"data/\")\n    fileloc = data_dir / exp_filename.format(VAR=variable, SEAS=season) # set the correct filename by replacing var and seas with the inputs specified for the function.\n    # Open the netcdf file\n    netcdf_data = cf.read(fileloc)\n    # select the variable data. \n    data = netcdf_data[0] # index 0 is the 3-D variable stored in the file.\n    data.cyclic('X') # set longitude to be cyclic\n    # select the years we want\n    data_years = data.subspace[index_range[0]:index_range[1],:,:]\n    # take the mean over those years\n    data_time_mean = data_years.collapse('mean', axes='T', squeeze=True)\n    # Select only that data in our target area.\n    data_time_mean_region = data_time_mean.subspace(X=cf.wi(lon_range[0], lon_range[1]), Y=cf.wi(lat_range[0],lat_range[1]))\n    \n    # Convert the hydrological variables from from m/s to mm/day \n    if variable == 'PRECT' or variable == 'PRECTMX' or variable == 'P-E':\n        data_time_mean_region.units = 'mm/day'\n    elif variable == 'TREFHT' or variable == 'TREFHTMX':\n        data_time_mean_region.units = cf.Units('degreesC')\n    \n    # Now, let's load up the weightings.\n    # Load up the gridcell weights (fraction of global area)\n    area_weight_fileloc = data_dir / 'area_weight.nc' \n    weight_nc_data = cf.read(area_weight_fileloc)\n    weight_data = weight_nc_data[0]\n\n    # Load up the gridcell land fraction\n    land_frac_fileloc = data_dir / 'land_fraction.nc' \n    land_frac_nc_data = cf.read(land_frac_fileloc)\n    land_frac_data = 0.01 * land_frac_nc_data[0] # convert from % to fraction, so that this totals to 1.\n\n    # Take the product of gridcell weight and land fraction\n    land_weight_data = weight_data * land_frac_data\n    \n    # Weight the gridcells in our target area so that they sum to one.\n    land_weight_data_space = land_weight_data.subspace(X=cf.wi(lon_range[0], lon_range[1]), Y=cf.wi(lat_range[0],lat_range[1]))\n    land_weight_data_space_array = land_weight_data_space.array / np.sum(land_weight_data_space.array)\n    \n    # take the mean over those years\n    data_land_weighted = land_weight_data_space_array * data_time_mean_region.array\n    data_time_mean_region_mean = np.sum(data_land_weighted)\n    \n    # Output this time-mean result\n    return data_time_mean_region, data_time_mean_region_mean, land_weight_data_space","pos":48,"type":"cell"}
{"cell_type":"code","exec_count":18,"id":"c0eebc","input":"lon_range = [-15, 10]\nlat_range = [45, 65]\n\ndata, mean, weight = get_regional_data_and_mean('control', 'TREFHT', 'ann', lon_range, lat_range, [10,29])\n\nbaseline_temp_UK = mean # you'll want to create variables to store the mean if you want to calculate the change between two experiments.\nprint(\"The baseline temperature over the UK is:\", baseline_temp_UK)\n\ncfp.setvars()\ncfp.con(data, blockfill=True, lines=False)\ncfp.con(weight, blockfill=True, lines=False) # You won't need to include these plots in your report but you can plot it to help you interpret your results for your region, i.e., what parts are actually land in the model.","output":{"0":{"name":"stdout","output_type":"stream","text":"The baseline temperature over the UK is: 9.770568055902611\n"},"1":{"data":{"image/png":"0d36067081f900041e27ab0870eeb4e537464306","text/plain":"<Figure size 842.4x597.6 with 3 Axes>"},"exec_count":18,"metadata":{"image/png":{"height":610,"width":728},"needs_background":"light"},"output_type":"execute_result"},"2":{"data":{"image/png":"46312098ad16311c7d7aaf34653e48b74e22054f","text/plain":"<Figure size 842.4x597.6 with 3 Axes>"},"exec_count":18,"metadata":{"image/png":{"height":615,"width":728},"needs_background":"light"},"output_type":"execute_result"}},"pos":50,"type":"cell"}
{"cell_type":"code","exec_count":19,"id":"5532ad","input":"# YOUR CODE HERE.","pos":53,"type":"cell"}
{"cell_type":"code","exec_count":2,"id":"60278e","input":"# pip install cf-plot","pos":6,"type":"cell"}
{"cell_type":"code","exec_count":20,"id":"b0361a","input":"lon_range = [60, 100]\nlat_range = [0, 40]\n\ndata_jja, mean_jja, weight = get_regional_data_and_mean('control', 'PRECT', 'jja', lon_range, lat_range, [10,29])\ndata_ann, mean_ann, weight = get_regional_data_and_mean('control', 'PRECT', 'ann', lon_range, lat_range, [10,29])\n\nbaseline_jja_precip_frac_mean = mean_jja / (4.*mean_ann) # we multiply by 4 as there are 12 months in the year vs. 3 in summer.\nprint(\"The fraction of rain that falls in the summer is:\", baseline_jja_precip_frac_mean)\n\n# Values above 0.25 indicate more rain falls in summer than we'd expect from averaging out over the year.\nbaseline_jja_precip_frac = data_jja / (4.*data_ann) # we multiply by 4 as there are 12 months in the year vs. 3 in summer.\ncfp.con(baseline_jja_precip_frac, blockfill=True, lines=False)","output":{"0":{"name":"stdout","output_type":"stream","text":"The fraction of rain that falls in the summer is: 0.39421085898952746\n"},"1":{"data":{"image/png":"1a56f7901d0cc8113f8b8d86399d0c8ce985f112","text/plain":"<Figure size 842.4x597.6 with 3 Axes>"},"exec_count":20,"metadata":{"image/png":{"height":550,"width":688},"needs_background":"light"},"output_type":"execute_result"}},"pos":55,"type":"cell"}
{"cell_type":"code","exec_count":21,"id":"1b3e8a","input":"# YOUR CODE HERE.","pos":57,"type":"cell"}
{"cell_type":"code","exec_count":22,"id":"8b214f","input":"def frac_geo_regional_data_and_mean(variable, season, lon_range, lat_range, year_range, frac_geo = 0.5):\n    \"\"\"\n    This function simply linearly scales the data at each latitude and longitude to be some fraction of the way\n    from the value in the RCP8.5 scenario towards the value in the GLENS scenario. \n    If fraction is 0, we return data_RCP8.5, and if the fraction is 1 we return data_GLENS.\n    The default is 0.5, i.e., offsetting halve of future warming with solar geoengineering.\n    \"\"\"\n    data_global_warming, mean_global_warming, weight = get_regional_data_and_mean('control', variable, season, lon_range, lat_range, year_range)\n    data_solar_geo, mean_solar_geo, weight = get_regional_data_and_mean('feedback', variable, season, lon_range, lat_range, year_range)\n\n    # linearly scale the data and means returned by get_regional_data_and_mean\n    mean_frac_geo = mean_global_warming + frac_geo * (mean_solar_geo - mean_global_warming)\n    # For the full data we need to add an extra step\n    data_frac_geo = data_global_warming.copy() # copy format of global warming data\n    # Replace data in this copy with the output of this function:\n    data_frac_geo[:] = data_global_warming.data.array + frac_geo * (data_solar_geo.data.array - data_global_warming.data.array)\n    \n    # Returns the same outputs as the get_regional_data_and_mean function but for this synthetic case.\n    return data_frac_geo, mean_frac_geo, weight","pos":59,"type":"cell"}
{"cell_type":"code","exec_count":23,"id":"bb478b","input":"#lons and lats for the UK\nlon_range = [-15, 10]\nlat_range = [45, 65]\n\n# get the data for a case where 50% of future warming is offset by stratospheric aerosol geoengineering. \ndata_50, mean_50, weight = frac_geo_regional_data_and_mean('TREFHT', 'ann', lon_range, lat_range, [75,94], frac_geo = 0.5)\n\nprint(mean_50)\n# Plot this data\ncfp.con(data_50, blockfill=True, lines=False)","output":{"0":{"name":"stdout","output_type":"stream","text":"12.33757872112359\n"},"1":{"data":{"image/png":"c048fdb054976bfe8a13619a671b959c0e656d7f","text/plain":"<Figure size 842.4x597.6 with 3 Axes>"},"exec_count":23,"metadata":{"image/png":{"height":610,"width":728},"needs_background":"light"},"output_type":"execute_result"}},"pos":61,"type":"cell"}
{"cell_type":"code","exec_count":24,"id":"829aa0","input":"# YOUR CODE HERE.","pos":63,"type":"cell"}
{"cell_type":"code","exec_count":25,"id":"aec0ee","input":"\"\"\"\nThere are two experiments, and two files for each variable:\nControl - starts in the year 2010 with GHG emissions following a high-end, rapid-warming scenario\nFeedback - starts in the year 2020 with the same GHG scenario as Control but with stratospheric aerosol \ngeoengineering deployed to keep temperatures at 2020 levels, see the paper linked to at the start for more.\n\"\"\"\ncontrol_filename = 'control.001.cam.h0.{VAR}.201001-209912.{SEAS}.nc' # The {VAR} and {SEAS} parts will be specified later\nfeedback_filename = 'feedback.001.cam.h0.{VAR}.202001-209912.{SEAS}.nc'","pos":66,"type":"cell"}
{"cell_type":"code","exec_count":26,"id":"7ec69d","input":"# this specifies the path to the data, using \"/\" to separate folders, and it should work in both mac and linux.\ndata_dir = Path(\"data/\")\n\n# Now we're going to open a test netCDF file. netCDF is just a standardized data filetype\ncontrol_fileloc = data_dir / control_filename.format(VAR='TREFHT', SEAS='ann') \n# feedback_fileloc = data_dir / feedback_filename.format(VAR='TREFHT', SEAS='ann') \n\n# Now we will open the netCDF file (.nc)\ncontrol_nc = cf.read(control_fileloc)\n# feedback_nc = cf.read(feedback_fileloc)\n\n# Let's see what's in it. print statements are a great way to work out what variables are.\nprint(control_nc)\n# print(feedback_nc)","output":{"0":{"name":"stdout","output_type":"stream","text":"[<CF Field: long_name=Reference height temperature(time(90), latitude(192), longitude(288)) K>,\n <CF Field: long_name=ch4 volume mixing ratio(time(90))>,\n <CF Field: long_name=co2 volume mixing ratio(time(90))>,\n <CF Field: long_name=current date (YYYYMMDD)(time(90))>,\n <CF Field: long_name=current seconds of current date(time(90))>,\n <CF Field: long_name=f11 volume mixing ratio(time(90))>,\n <CF Field: long_name=f12 volume mixing ratio(time(90))>,\n <CF Field: long_name=latitude weights(latitude(192))>,\n <CF Field: long_name=n2o volume mixing ratio(time(90))>,\n <CF Field: long_name=current day (from base day)(time(90))>,\n <CF Field: long_name=current seconds of current day(time(90))>,\n <CF Field: long_name=current timestep(time(90))>,\n <CF Field: long_name=total solar irradiance(time(90)) W/m2>]\n"}},"pos":68,"type":"cell"}
{"cell_type":"code","exec_count":27,"id":"955566","input":"# As this is a list, note the [], and we want the first element we use the index 0. Python starts counting indices from 0.\ntemp2m = control_nc[0]\nprint(temp2m)\n# temp2m = feedback_nc[0]\n# print(temp2m)","output":{"0":{"name":"stdout","output_type":"stream","text":"Field: long_name=Reference height temperature (ncvar%TREFHT)\n------------------------------------------------------------\nData            : long_name=Reference height temperature(time(90), latitude(192), longitude(288)) K\nCell methods    : time(90): mean\nDimension coords: time(90) = [2010-07-01 00:00:00, ..., 2099-04-01 00:00:00] 365_day\n                : latitude(192) = [-90.0, ..., 90.0] degrees_north\n                : longitude(288) = [0.0, ..., 358.75] degrees_east\n"}},"pos":70,"type":"cell"}
{"cell_type":"code","exec_count":28,"id":"40bb8e","input":"# Now let's select the 30 years between 2075 - 2094. there's an issue with the last few years so we won't run up until 2100.\ntemp2m_20yrs = temp2m.subspace[55:75,:,:] # The experiment starts its index from 2010 [0], hence 65 for 2075.\nprint(temp2m_20yrs)","output":{"0":{"name":"stdout","output_type":"stream","text":"Field: long_name=Reference height temperature (ncvar%TREFHT)\n------------------------------------------------------------\nData            : long_name=Reference height temperature(time(20), latitude(192), longitude(288)) K\nCell methods    : time(20): mean\nDimension coords: time(20) = [2065-06-16 00:00:00, ..., 2084-06-16 00:00:00] 365_day\n                : latitude(192) = [-90.0, ..., 90.0] degrees_north\n                : longitude(288) = [0.0, ..., 358.75] degrees_east\n"}},"pos":72,"type":"cell"}
{"cell_type":"code","exec_count":29,"id":"67fbe1","input":"temp2m_20yrmean = temp2m_20yrs.collapse('mean', axes='T') # Collapse calculates a statistical function (a mean here) on the specified axis (T for time)\nprint(temp2m_20yrmean)","output":{"0":{"name":"stdout","output_type":"stream","text":"Field: long_name=Reference height temperature (ncvar%TREFHT)\n------------------------------------------------------------\nData            : long_name=Reference height temperature(time(1), latitude(192), longitude(288)) K\nCell methods    : time(1): mean\nDimension coords: time(1) = [2074-12-01 00:00:00] 365_day\n                : latitude(192) = [-90.0, ..., 90.0] degrees_north\n                : longitude(288) = [0.0, ..., 358.75] degrees_east\n"}},"pos":74,"type":"cell"}
{"cell_type":"code","exec_count":3,"id":"cdd34b","input":"import numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.colors as colors\n\nimport cf\nimport cfplot as cfp\nfrom netCDF4 import Dataset\nfrom pathlib import Path","pos":8,"type":"cell"}
{"cell_type":"code","exec_count":30,"id":"64b8c4","input":"cfp.con(temp2m_20yrmean)","output":{"0":{"data":{"image/png":"0071da80032fa579bcb2b834366d6b3d96a14d63","text/plain":"<Figure size 842.4x597.6 with 3 Axes>"},"exec_count":30,"metadata":{"image/png":{"height":534,"width":728},"needs_background":"light"},"output_type":"execute_result"}},"pos":76,"type":"cell"}
{"cell_type":"code","exec_count":4,"id":"6b871b","input":"from platform import python_version\n\nprint(python_version())","output":{"0":{"name":"stdout","output_type":"stream","text":"3.8.5\n"}},"pos":9,"type":"cell"}
{"cell_type":"code","exec_count":5,"id":"520aae","input":"def get_time_mean_data(experiment, variable, season, year_range):\n    # INPUTS FOR FUNCTION:\n    # experiment = 'control' - for the global warming scenario, or 'feedback' - for the stratospheric aerosol geoengineering experiment.\n    # Variable = 'TREFHT', 'TREFHTMX', 'PRECT', 'PRECTMX', or 'P-E'\n    # TREFHT = Temperature at the reference height (2m), i.e. air temperature\n    # TREFHTMX = The maximum recorded air temperature in a month\n    # PRECT = Precipitation rate (rain + snow)\n    # PRECTMX = The maximum recorded precipitation rate at the model timestep (30 mins)\n    # P-E = Precipitation minus total Evaporation (evaporation, transpiraton and sublimation)\n    # season = 'ann', 'djf', 'mam', 'jja', 'son' = annual-mean or season-mean\n    # year_range = [start_year, end_year], default is 75 to 94, i.e., a range of 20 years.\n    \n    if len(year_range) != 2:\n        print('year_range must have 2 elements, you inputted:', year_range)\n    \n    # Select the correct filename format and select the correct indices.\n    if experiment == 'control':\n        exp_filename = 'control.001.cam.h0.{VAR}.201001-209912.{SEAS}.nc'\n        index_range = [year_range[0] - 10, year_range[1] - 10] # starts in year 2010 so -10\n    elif experiment == 'feedback':\n        exp_filename = 'feedback.001.cam.h0.{VAR}.202001-209912.{SEAS}.nc'\n        index_range = [year_range[0] - 20, year_range[1] - 20] # starts in year 2020 so -20\n    else:\n        print(experiment, 'not recognized. must be either control or feedback')\n    \n    # Specify filename and location\n    data_dir = Path(\"data/\")\n    fileloc = data_dir / exp_filename.format(VAR=variable, SEAS=season) # set the correct filename by replacing var and seas with the inputs specified for the function.\n    # Open the netcdf file\n    netcdf_data = cf.read(fileloc)\n    # select the variable data. \n    data = netcdf_data[0] # index 0 is the 3-D variable stored in the file.\n    # select the years we want\n    data_years = data.subspace[index_range[0]:index_range[1],:,:]\n    # take the mean over those years\n    data_time_mean = data_years.collapse('mean', axes='T')\n    \n    # Convert the hydrological variables from from m/s to mm/day \n    if variable == 'PRECT' or variable == 'PRECTMX' or variable == 'P-E':\n#         data_time_mean = data_time_mean * 1000. * 60 * 60 * 24\n        data_time_mean.units = 'mm/day'\n    elif variable == 'TREFHT' or variable == 'TREFHTMX':\n        data_time_mean.units = cf.Units('degreesC')\n    \n    # Output this time-mean result\n    return data_time_mean","pos":13,"type":"cell"}
{"cell_type":"code","exec_count":6,"id":"660bda","input":"# We define a variable to store the time-mean output and give it a name that makes sense.\nglobal_warming_trefht_ann = get_time_mean_data('control', 'TREFHT', 'ann', [75,94])\n# Then we let the plotting routine do its thing.\ncfp.con(global_warming_trefht_ann)","output":{"0":{"data":{"image/png":"96ed9f31f75718f90b8352db2825b9798d87cea5","text/plain":"<Figure size 842.4x597.6 with 3 Axes>"},"exec_count":6,"metadata":{"image/png":{"height":534,"width":728},"needs_background":"light"},"output_type":"execute_result"}},"pos":15,"type":"cell"}
{"cell_type":"code","exec_count":7,"id":"198ed9","input":"# As before, we define a variable to store the time-mean output and give it a name that makes sense.\nglobal_warming_data = get_time_mean_data('control', 'TREFHT', 'ann', [75,94])\nbaseline_data = get_time_mean_data('control', 'TREFHT', 'ann', [10,29])\n# We can directly plot the anomaly by subtracting one from the other, and asking cfp.con to plot the result.\ncfp.con(global_warming_data - baseline_data)","output":{"0":{"data":{"image/png":"88280cb35cbe0b0fc35c7b6aa40c08a611921fc8","text/plain":"<Figure size 842.4x597.6 with 3 Axes>"},"exec_count":7,"metadata":{"image/png":{"height":534,"width":728},"needs_background":"light"},"output_type":"execute_result"}},"pos":21,"type":"cell"}
{"cell_type":"code","exec_count":9,"id":"45d41a","input":"# let's set the variable and season to plot. defining a variable means we don't have to repeat ourselves and there's less chance of making mistakes.\nvar_2_plot = 'TREFHT'\nseas_2_plot = 'ann'\n\n# Gather the annual-mean temperature data for the 3 cases\nglobal_warming_data = get_time_mean_data('control', var_2_plot, seas_2_plot, [75,94])\nbaseline_data = get_time_mean_data('control', var_2_plot, seas_2_plot, [10,29])\n# ADD YOUR LINE FOR THE SOLAR GEO CASE HERE\n\n# Now we define the anomaly (difference) between the future and baseline cases.\nglobal_warming_anom = global_warming_data - baseline_data\n# ADD YOUR LINE FOR THE SOLAR GEO ANOMALY HERE\n\n# Now, we set the contours and colorbar settings.\n# cfp.levs() defines the levels for the contourplot, leaving it blank let's the program choose the levels itself. Any values set here will be used in later plots but this can be reset by making a blank call with cfp.levs().\ncfp.levs(min=-5,max=15,step=5)\n# cfp.cscale() defines the colorscale for the contourplot, leaving it blank let's the program choose the colour scale itself.\ncfp.cscale('scale1') # We'll use scale1 which goes from blue through white to red, a good colour scale for temperature change.\n\n# Now we make the contour plots\ncfp.con(global_warming_anom)\n# ADD YOUR LINE FOR THE SOLAR GEO ANOMALY CONTOUR PLOT HERE","output":{"0":{"data":{"image/png":"8a58ed52edb305f38921ee9b63be0e935c30bc77","text/plain":"<Figure size 842.4x597.6 with 3 Axes>"},"exec_count":9,"metadata":{"image/png":{"height":534,"width":728},"needs_background":"light"},"output_type":"execute_result"}},"pos":24,"type":"cell"}
{"cell_type":"markdown","id":"00acce","input":"Now we can see what this temperature \"Field\" looks like. It has a data part, a cell method, and dimensions.","pos":71,"type":"cell"}
{"cell_type":"markdown","id":"021bec","input":"# FIN.\n\nYou are done, great! \n\n\n\n\nI've copied ","pos":64,"type":"cell"}
{"cell_type":"markdown","id":"038743","input":"The colourbars will be a bit off but you get the picture.","pos":43,"type":"cell"}
{"cell_type":"markdown","id":"0ee9d1","input":"## Question: what is wrong with claiming the mean temperature printed here is the UK's mean temperature?","pos":51,"type":"cell"}
{"cell_type":"markdown","id":"164c1b","input":"## Please run the first two cells.","pos":4,"type":"cell"}
{"cell_type":"markdown","id":"18d2ec","input":"## Fantastic, now you have everything you need to produce high-quality map plots for your group project!\n\nIf you want to get a bit fancier, you can try some of the following stuff which you could try implementing in your project.\n\nBrowse through these as I've put them in no particular order, and some are more involved than others","pos":46,"type":"cell"}
{"cell_type":"markdown","id":"200c96","input":"## Task E2. Plot the change in summer rainfall in India between the global warming case and the baseline.","pos":56,"type":"cell"}
{"cell_type":"markdown","id":"22924a","input":"## TASK E1. Copy the code from above and modify it so that you get a more accurate value for the UK's average temperature.","pos":52,"type":"cell"}
{"cell_type":"markdown","id":"2829f2","input":"## TASK 4.2: Plotting percentage change for hydrological variables.\n\nThe problem with plotting absolute changes in hydrological variables is that some regions get several mm of rain per day on average whereas others get only mm per year on average.\n\nBelow is some code to plot percentage changes, run it. then follow the instructions afterwards to tidy it up.","pos":35,"type":"cell"}
{"cell_type":"markdown","id":"34c39e","input":"With this function you specify the experiment, variable, season and year-range that you want to analyze, and it returns the time-mean over the year-range you specify for that combination. I.e., it follows the processing steps we went through above.","pos":12,"type":"cell"}
{"cell_type":"markdown","id":"3608fe","input":"Now, let's use the function above to produce the same plot as before:","pos":14,"type":"cell"}
{"cell_type":"markdown","id":"36d74b","input":"## TASK 3.4: Repeat the above for maximum temperature.\nCopy the code section from above and edit it to produce plots of the change in maximum annual temperature (TREFHTMX). You'll probably need to change the colourbar range to make it look nice.","pos":30,"type":"cell"}
{"cell_type":"markdown","id":"371653","input":"### TASK 3.1: produce plots to show how the change in temperature over the 21st century under the global warming and solar geoengineering scenarios.","pos":18,"type":"cell"}
{"cell_type":"markdown","id":"3cd8a4","input":"## Task 6. Outputting plots as png files.\n\nTo save image files you'll need to add a couple of lines telling the program to output the graphics to file:\n- Copy any of the code sections above to the section below.\n- put the line: cfp.gopen(file='MY_DESCRIPTIVE_FILENAME.png') just before the first cfp calls associated with your map.\n- change the filename!\n- put the line: cfp.gclose() after the end of the cfp calls associated with your map.\nIf it works, you won't see the image pop up in the notebook, you'll have to check the folder. It's probably best to comment out these gopen and gclose lines while you're editing the map and only put them in when finished.","pos":44,"type":"cell"}
{"cell_type":"markdown","id":"403e9f","input":"## Extra 2. Different seasons\n\nInstead of looking at changes in the annual-mean (or maximum) you could see how things are changing in different seasons. This is straightforward; simply change the variable \"season\" from \"ann\" to \"djf\", \"mam\", \"jja\" or \"son\".\n\nYou could also look at the seasonality, e.g. taking the difference between jja and djf for each case, or separately assessing changes in summer and winter.\n\nBelow is an example showing the fraction of rain that falls in the wet season in india (jja / ann) in the baseline","pos":54,"type":"cell"}
{"cell_type":"markdown","id":"415337","input":"Here's some example code which plots UK temperatures in this 50% geoengineering case.","pos":60,"type":"cell"}
{"cell_type":"markdown","id":"4b15ac","input":"Below is an example using this new function to create regional plots.\n- The regional plot works the same as before but instead of specifying the area in the cfp.con() call, it is specified by the function which gets the data.\n- The function outputs 3 things which are stored in: data, mean, weight:\n- data: same as earlier function but only over the specified region\n- mean: the land-area weighted mean of the data over the specified area\n- weight: the weighting applied, i.e., the land area weight (a product of the relative area of gridcells [1x1 degree lon lat is a much smaller area at poles than at equator], and land area fraction of each grid cell)","pos":49,"type":"cell"}
{"cell_type":"markdown","id":"4b8625","input":"We've got a plot of the average absolute temperature in the years 2075-2094 in an extreme global warming scenario but this doesn't tell us very much on its own. For example, how much has the temperature changed?","pos":78,"type":"cell"}
{"cell_type":"markdown","id":"61ea98","input":"## Extra 1. Land-area-weighted regional means.\n\nThis function is a two-for-one, it subspaces the region of interest and it calculates the land-area weighted mean over the area plotted.","pos":47,"type":"cell"}
{"cell_type":"markdown","id":"720264","input":"## Section 4: Plotting hydrological change\n\n## TASK 4.1: Picking a good colourscale and colorbar settings for hydrological change.\n\nRed for hot, positive trends and blue for cold, negative trends works great for temperature but positive trends equal more water for hydrological variables so it'll be a bit confusing if hot, red colours = wetter. So, let's pick another colourscale.\n\n- Copy the code section above and this time plot precipitation change, 'PRECT'.\n- Change the colourscale to 'BrownBlue12'\n- Adjust the levels plotted and / or the number of colours above / below 0 as before to produce a nice-looking plot. HINT: it's OK to not plot the full range of data. \n- Change the title and add a colorbar label by adding: \", colorbar_title='Precipitation Change (mm/day)'\" to the cfp.con() call.\n- Optionally, you can remove the black lines from the contour plots by adding: \", lines=False\" to the end of the calls to cfp.con(). This can be useful if you have well-separated contours in some places but tightly packed lines in others that make it hard to see.","pos":33,"type":"cell"}
{"cell_type":"markdown","id":"743887","input":"control_nc is a list of the \"fields\" or variables in the netcdf file. The first \"Field\" listed is the variable we're interested in, the reference height temperature. This is the 2m air temperature which is the standard way of reporting air temperatures. It has the short-name \"TREFHT\" so let's check that \"field\" out. The other fields describe some of the conditions in the climate model, e.g. CO2 concentration, but we can ignore those.","pos":69,"type":"cell"}
{"cell_type":"markdown","id":"750cd7","input":"# 0. Background on stratospheric aerosol geoengineering","pos":1,"type":"cell"}
{"cell_type":"markdown","id":"77ad73","input":"We now effectively have a 2-D longitude-latitude slice. Let's plot it.","pos":75,"type":"cell"}
{"cell_type":"markdown","id":"79d51a","input":"YOUR FIGURE CAPTION HERE.","pos":29,"type":"cell"}
{"cell_type":"markdown","id":"7f4b54","input":"### Our plot shows annual-mean ('ann') temperature ('TREFHT') over the years 2075 to 2094 inclusive ([75,94]) for the experiment 'Control'\n\nGreat, but knowing what end of century absolute temperatures are in this model doesn't tell us much, let's look at changes in temperature.","pos":16,"type":"cell"}
{"cell_type":"markdown","id":"83711c","input":"# Solar Geoengineering Practical --> leading up to group project\n\nThis practical will introduce you to the data and plotting routines that you will use in your group project.","pos":0,"type":"cell"}
{"cell_type":"markdown","id":"8cee1d","input":"Great, we have a nice-looking map. And, we can see that it's automatically labeled the colorbar.","pos":77,"type":"cell"}
{"cell_type":"markdown","id":"976620","input":"## X. Background on using CF and CF-plot.\n\nThis is some background on using the ","pos":65,"type":"cell"}
{"cell_type":"markdown","id":"a14ec3","input":"You should now have 2 ugly-looking plots that don't tell you much. The plots have no titles, the contour levels are too far apart and the colors are off. Let's fix that.\n- Copy the code from above into the section below. \n- replace the line: \"cfp.con(global_warming_anom)\" with \"cfp.con(global_warming_anom, title='global warming - baseline Temperature Change (K)')\" to add a title to that plot.\n- Using the same approach, add a title to the solar geoengineering anom plot\n- in the line: cfp.levs(...), Change the values of min, max and step to cover the full range (or near-enough) for both anomalies and have a reasonable step-size. HINT: The earlier plots show the range of values for each anomaly. HINT2: the step-size needs to be small enough that you can see details, but not so small that the labels overrun each other or the plot becomes to busy to read.\n\nFor the colors to look right the levels have to be symmetric, e.g. -3 to +3, OR we need to tell the colorscale how to line up with the levels we want to plot. \n- if you have an asymmetric colorscale replace the line \"cfp.cscale('scale1')\" with \"cfp.cscale('scale1', below=X, above=Y)\" where X is the number of steps from zero to your minimum + 1 (for the less than extension of the colorscale), and Y is the number of steps from zero to your maximum + 1.","pos":25,"type":"cell"}
{"cell_type":"markdown","id":"a81373","input":"## TASK 3.3: Write a figure caption for these two plots.\n\nHINT: Check out Figure 6 in the GLENS paper linked to at the top.\n\nHINT2: Don't plagiarize the text, I'll be running your reports through Turnitin.\n\nHINT3: We are only looking at a single ensemble member rather than the entire ensemble.\n","pos":28,"type":"cell"}
{"cell_type":"markdown","id":"a966b6","input":"## 1. install and load modules","pos":3,"type":"cell"}
{"cell_type":"markdown","id":"b14a98","input":"# 2. Loading the data","pos":10,"type":"cell"}
{"cell_type":"markdown","id":"b4538c","input":"## Task 5. Regional plots\n\nProducing regional plots is pretty straight-forward, all you need to do is specify the latitude and longitude in the cfp.mapset function. NOTE like the levels and colourscale functions this is a persistent change that will affect all subsequent plots so if you want to plot somewhere else after, you will have to reset it with an empty call: cfp.mapset().\n- Copy your blocky percentage change plot below.\n- Add the line: cfp.mapset(lonmin=lon_min, lonmax=lon_max, latmin=lat_min, latmax=lat_max) before the first cfp.con() call.\n- Then specify lon_max = XXX, etc. for these 4 variables, replacing the XXX's with appropriate values so that you can plot regional changes around the UK.","pos":41,"type":"cell"}
{"cell_type":"markdown","id":"b55f5c","input":"## Extra 3. Fractional geoengineering\n\nThe level of cooling achieved by stratospheric aerosol geoengineering would be a choice, however we've only got results for 1 choice: offsetting all warming from 2020. This The might result in an overshoot in your region for some measures, e.g., precip might increase +5% under global warming and decrease -3% under solar geoengineering. The following functino let's you generate results for a synthetic case where only a fraction of the warming is offset by stratospheric aerosol geoengineering, i.e., we linearly scale between the global warming and the solar geoengineering case.","pos":58,"type":"cell"}
{"cell_type":"markdown","id":"b5cb61","input":"Now let's open a file and see what's in it.","pos":67,"type":"cell"}
{"cell_type":"markdown","id":"b785d4","input":"### TASK 3.2: produce NICE plots to showing the change in temperature over the 21st century under the global warming and solar geoengineering scenarios.\nTo compare the temperature changes between these two future cases it is useful to plot them with the same colorbars.\n\nAdd lines to plot the solar geo case into the code box below.","pos":23,"type":"cell"}
{"cell_type":"markdown","id":"bb27a6","input":"### Now I'll define a function that will combine the steps above to save you time.","pos":11,"type":"cell"}
{"cell_type":"markdown","id":"bb6acb","input":"YOUR MAX TEMP FIGURE CAPTION HERE.","pos":32,"type":"cell"}
{"cell_type":"markdown","id":"c15aec","input":"# 3. Plotting a change in climate","pos":17,"type":"cell"}
{"cell_type":"markdown","id":"c505bf","input":"If that worked you should have some publication-quality maps! Exactly the kind of thing you will want for your report...","pos":27,"type":"cell"}
{"cell_type":"markdown","id":"c62ffd","input":"We've got 3 plots, 2 % changes and the baseline precipitation, as it's good to have this for reference to help interpret the percentage changes.\n\nThere are a couple of problems though. Go back and edit the code above to sort out the colorbars.\n- The % change plots are being messed up by an extreme % change in the Sahara. This will be due to some region seeing something like 0.001 mm/day before now seeing 0.01 mm/day. We want to have a scale that suits the full area plotted, so change the range and step size to make a clearer plot.\n- The absolute precipitation plot for the baseline has a similar issue, there is some extreme location with >32 mm/day of rain. Again, we want to have a colorbar range suitable for the whole world. Let's be fancy and use a customized logarithmic precipitation scale that will work for deserts and rainforests. replace the cfp.levs() and cfp.cscale() lines with the following:\n\ncfp.levs(manual=[0.,0.1, 0.2, 0.5, 1., 2., 4., 8., 16., 32.], extend='max')\n\ncfp.cscale('precip_11lev')","pos":37,"type":"cell"}
{"cell_type":"markdown","id":"d7185d","input":"Great, we can see that we now have 20 years and it's the years we wanted.\n\nNow let's take the mean of those 20 years.","pos":73,"type":"cell"}
{"cell_type":"markdown","id":"e05dca","input":"First, I'll plot the temperature change between the global warming case and the baseline. Then you will do the same for the temperature change between the solar_geo case and the baseline.","pos":20,"type":"cell"}
{"cell_type":"markdown","id":"e7b389","input":"In this practical we will analyze the climate response to stratospheric aerosol geoengineering using results from the Geoengineering Large Ensemble (GLENS) runs. You will need to write about the GLENS experiments in the methods section of your group report. You can find out more about the GLENS runs here: https://journals.ametsoc.org/doi/full/10.1175/BAMS-D-17-0267.1 \n\nThere are 2 GLENS experiments:\n- **Control** - starts in the year 2010 with GHG emissions following a high-end, rapid-warming scenario\n- **Feedback** - starts in the year 2020 with the same GHG scenario as Control but with stratospheric aerosol geoengineering deployed to keep temperatures at 2020 levels, see the paper linked to at the start for more.\n\nWe'll be comparing 3 different cases based on those GLENS experiments:\n- **baseline**: the climate of today, 2010 - 2029 in the control experiment.\n- **global_warming**: the late 21st century in our global warming scenario: 2075 - 2094 in the control experiment. \n- **solar_geo**: the late 21st century in our stratospheric aerosol geoengineering experiment: 2075 - 2094 in the feedback experiment.\n\nYou can find a more general overview of stratospheric aerosol geoengineering here: https://onlinelibrary.wiley.com/doi/full/10.1002/wcc.423. This will be useful for the introduction to your report.\n\nYou don't need to read these papers to understand this practical though, so let's get started.","pos":2,"type":"cell"}
{"cell_type":"markdown","id":"e7b691","input":"This resolution issue isn't a big problem at the global level but it will be once you zoom in to your region so it will be worthwhile using this block_fill option to avoid over-interpreting your data.","pos":40,"type":"cell"}
{"cell_type":"markdown","id":"f00976","input":"In this practical we'll be comparing 3 different cases:\n- **baseline**: the climate of today, 2010 - 2029 in the control experiment\n- **global_warming**: the late 21st century in our global warming scenario: 2075 - 2094 in the control experiment. \n- **solar_geo**: the late 21st century in our stratospheric aerosol geoengineering experiment: 2075 - 2094 in the feedback experiment.","pos":19,"type":"cell"}
{"cell_type":"markdown","id":"f81855","input":"## Restart your kernel (next to Stop and Tab). You should be able to run all other cells as intended afterwards.","pos":7,"type":"cell"}
{"cell_type":"markdown","id":"fa92c7","input":"## Task 4.3: Blockiness.\n\nThese contour plots produce smooth contours but the data underneath is blocky. The model used only has a resolution of 1 degree in longitude and latitude, so let's see what the actual data shows.\n\n- copy the code section from above and add the following to each cfp.con() call: \", blockfill=True, lines=False\"","pos":38,"type":"cell"}
{"cell_type":"markdown","id":"fc469a","input":"## Task E3: copy the above code to produce 3 temperature anomaly plots: global warming, solar geo and 50% solar geo all relative to baseline, to confirm that the code has worked as intended.\nHint: Copy your nice temperature plot settings from farther above and integrate those too.","pos":62,"type":"cell"}
{"id":0,"time":1612806049220,"type":"user"}
{"last_load":1613142751822,"type":"file"}